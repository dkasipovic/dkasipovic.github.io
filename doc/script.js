const STORAGE_DOCS = 'docedit_documents', STORAGE_THEME = 'docedit_theme', STORAGE_SORT = 'docedit_sort', DEBOUNCE_MS = 500;
let state = { documents: [], currentDocId: null, sortBy: 'date', theme: 'auto', saveTimeout: null, pendingShare: null };
const $ = s => document.querySelector(s);
const els = { docList: $('#docList'), emptyState: $('#emptyState'), editorView: $('#editorView'), titleInput: $('#titleInput'), contentTextarea: $('#contentTextarea'), saveStatus: $('#saveStatus'), saveIcon: $('#saveIcon'), saveText: $('#saveText'), createdAt: $('#createdAt'), modifiedAt: $('#modifiedAt'), newDocBtn: $('#newDocBtn'), deleteBtn: $('#deleteBtn'), sortDate: $('#sortDate'), sortTitle: $('#sortTitle'), themeToggle: $('#themeToggle'), themeIcon: $('#themeIcon'), themeLabel: $('#themeLabel'), passwordProtect: $('#passwordProtect'), passwordGroup: $('#passwordGroup'), sharePassword: $('#sharePassword'), generateLink: $('#generateLink'), linkPreview: $('#linkPreview'), linkActions: $('#linkActions'), copyLink: $('#copyLink'), openLink: $('#openLink'), sidebar: $('#sidebar'), sidebarOverlay: $('#sidebarOverlay'), menuToggle: $('#menuToggle'), sharePanel: $('#sharePanel'), shareOverlay: $('#shareOverlay'), shareToggleMobile: $('#shareToggleMobile'), passwordModal: $('#passwordModal'), modalPassword: $('#modalPassword'), modalError: $('#modalError'), modalCancel: $('#modalCancel'), modalDecrypt: $('#modalDecrypt'), toast: $('#toast'), toastIcon: $('#toastIcon'), toastText: $('#toastText') };
const generateId = () => crypto.randomUUID();
const formatDate = t => { const d = new Date(t), n = new Date(), x = n - d; if (x < 6e4) return 'Just now'; if (x < 36e5) return `${Math.floor(x / 6e4)}m ago`; if (x < 864e5) return `${Math.floor(x / 36e5)}h ago`; return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: d.getFullYear() !== n.getFullYear() ? 'numeric' : undefined }) };
const formatFullDate = t => new Date(t).toLocaleString('en-US', { month: 'short', day: 'numeric', year: 'numeric', hour: '2-digit', minute: '2-digit' });
const showToast = (m, i = 'âœ“', d = 3000) => { els.toastIcon.textContent = i; els.toastText.textContent = m; els.toast.classList.add('visible'); setTimeout(() => els.toast.classList.remove('visible'), d) };
const loadDocuments = () => { try { const d = localStorage.getItem(STORAGE_DOCS); state.documents = d ? JSON.parse(d) : []; } catch (e) { state.documents = []; } };
const saveDocuments = () => { try { localStorage.setItem(STORAGE_DOCS, JSON.stringify(state.documents)); } catch (e) { showToast('Failed to save', 'âš ï¸'); } };
const loadPreferences = () => { state.theme = localStorage.getItem(STORAGE_THEME) || 'auto'; state.sortBy = localStorage.getItem(STORAGE_SORT) || 'date'; };
const savePreferences = () => { localStorage.setItem(STORAGE_THEME, state.theme); localStorage.setItem(STORAGE_SORT, state.sortBy); };
const applyTheme = () => { let t = state.theme; if (t === 'auto') t = window.matchMedia('(prefers-color-scheme:dark)').matches ? 'dark' : 'light'; document.documentElement.setAttribute('data-theme', t); els.themeIcon.textContent = { auto: 'â—', light: 'â˜€', dark: 'â˜¾' }[state.theme]; els.themeLabel.textContent = { auto: 'Auto', light: 'Light', dark: 'Dark' }[state.theme]; };
const cycleTheme = () => { const t = ['auto', 'light', 'dark']; state.theme = t[(t.indexOf(state.theme) + 1) % 3]; applyTheme(); savePreferences(); };
const getSortedDocuments = () => { const d = [...state.documents]; if (state.sortBy === 'date') d.sort((a, b) => b.modifiedAt - a.modifiedAt); else d.sort((a, b) => a.title.localeCompare(b.title)); return d; };
const escapeHtml = t => { const d = document.createElement('div'); d.textContent = t; return d.innerHTML; };
const renderDocList = () => { const d = getSortedDocuments(); els.docList.innerHTML = d.map(doc => `<div class="doc-item ${doc.id === state.currentDocId ? 'active' : ''}" data-id="${doc.id}"><span class="doc-icon ${doc.isShared ? 'shared' : ''}">${doc.isShared ? 'â˜…' : 'ðŸ“„'}</span><div class="doc-info"><div class="doc-title">${escapeHtml(doc.title || 'Untitled')}</div><div class="doc-meta">${formatDate(doc.modifiedAt)}</div></div></div>`).join(''); els.sortDate.classList.toggle('active', state.sortBy === 'date'); els.sortTitle.classList.toggle('active', state.sortBy === 'title'); };
const selectDocument = id => { state.currentDocId = id; const doc = state.documents.find(d => d.id === id); if (!doc) { els.emptyState.style.display = 'flex'; els.editorView.style.display = 'none'; return; } els.emptyState.style.display = 'none'; els.editorView.style.display = 'flex'; els.titleInput.value = doc.title; els.contentTextarea.value = doc.content; els.createdAt.textContent = `Created: ${formatFullDate(doc.createdAt)}`; els.modifiedAt.textContent = `Modified: ${formatFullDate(doc.modifiedAt)}`; updateSaveStatus('saved'); clearShareLink(); renderDocList(); closeSidebar(); };
const createDocument = (title = 'Untitled Document', content = '', isShared = false, isEncrypted = false) => { const now = Date.now(); const doc = { id: generateId(), title, content, createdAt: now, modifiedAt: now, isShared, isEncrypted }; state.documents.unshift(doc); saveDocuments(); renderDocList(); selectDocument(doc.id); return doc; };
const updateCurrentDocument = updates => { const doc = state.documents.find(d => d.id === state.currentDocId); if (!doc) return; Object.assign(doc, updates, { modifiedAt: Date.now() }); saveDocuments(); els.modifiedAt.textContent = `Modified: ${formatFullDate(doc.modifiedAt)}`; renderDocList(); };
const deleteCurrentDocument = () => { if (!state.currentDocId || !confirm('Delete this document?')) return; state.documents = state.documents.filter(d => d.id !== state.currentDocId); saveDocuments(); state.currentDocId = null; renderDocList(); if (state.documents.length > 0) selectDocument(getSortedDocuments()[0].id); else { els.emptyState.style.display = 'flex'; els.editorView.style.display = 'none'; } closeSharePanel(); showToast('Document deleted', 'ðŸ—‘ï¸'); };
const updateSaveStatus = s => { els.saveStatus.classList.remove('saved', 'saving'); els.saveStatus.classList.add(s); els.saveIcon.textContent = s === 'saving' ? 'â—‹' : 'âœ“'; els.saveText.textContent = s === 'saving' ? 'Saving...' : 'Saved'; };
const debouncedSave = () => { updateSaveStatus('saving'); if (state.saveTimeout) clearTimeout(state.saveTimeout); state.saveTimeout = setTimeout(() => { updateCurrentDocument({ title: els.titleInput.value, content: els.contentTextarea.value }); updateSaveStatus('saved'); }, DEBOUNCE_MS); };
async function compress(d) { const e = new TextEncoder(); const s = new Blob([e.encode(d)]).stream().pipeThrough(new CompressionStream('gzip')); const c = []; const r = s.getReader(); while (true) { const { done, value } = await r.read(); if (done) break; c.push(value); } return new Uint8Array(await new Blob(c).arrayBuffer()); }
async function decompress(d) { const s = new Blob([d]).stream().pipeThrough(new DecompressionStream('gzip')); const c = []; const r = s.getReader(); while (true) { const { done, value } = await r.read(); if (done) break; c.push(value); } return new TextDecoder().decode(await new Blob(c).arrayBuffer()); }
async function deriveKey(p, s) { const k = await crypto.subtle.importKey('raw', new TextEncoder().encode(p), 'PBKDF2', false, ['deriveBits', 'deriveKey']); return crypto.subtle.deriveKey({ name: 'PBKDF2', salt: s, iterations: 100000, hash: 'SHA-256' }, k, { name: 'AES-GCM', length: 256 }, false, ['encrypt', 'decrypt']); }
async function encrypt(d, p) { const s = crypto.getRandomValues(new Uint8Array(16)); const i = crypto.getRandomValues(new Uint8Array(12)); const k = await deriveKey(p, s); const e = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: i }, k, new TextEncoder().encode(d)); const c = new Uint8Array(s.length + i.length + e.byteLength); c.set(s, 0); c.set(i, s.length); c.set(new Uint8Array(e), s.length + i.length); return c; }
async function decrypt(c, p) { const s = c.slice(0, 16); const i = c.slice(16, 28); const t = c.slice(28); const k = await deriveKey(p, s); const d = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: i }, k, t); return new TextDecoder().decode(d); }
const uint8ToBase64 = u => { let b = ''; for (let i = 0; i < u.length; i++)b += String.fromCharCode(u[i]); return btoa(b).replace(/\+/g, '-').replace(/\//g, '_').replace(/=+$/, ''); };
const base64ToUint8 = b => { b = b.replace(/-/g, '+').replace(/_/g, '/'); while (b.length % 4) b += '='; const s = atob(b); const u = new Uint8Array(s.length); for (let i = 0; i < s.length; i++)u[i] = s.charCodeAt(i); return u; };
async function generateShareLink() { const doc = state.documents.find(d => d.id === state.currentDocId); if (!doc) return; const payload = JSON.stringify({ title: doc.title, content: doc.content }); const usePassword = els.passwordProtect.checked; const password = els.sharePassword.value.trim(); if (usePassword && !password) { showToast('Please enter a password', 'âš ï¸'); els.sharePassword.focus(); return; } try { let data, isEncrypted = false; if (usePassword && password) { const compressed = await compress(payload); const compressedBase64 = uint8ToBase64(compressed); const encrypted = await encrypt(compressedBase64, password); data = uint8ToBase64(encrypted); isEncrypted = true; } else { const compressed = await compress(payload); data = uint8ToBase64(compressed); } const envelope = JSON.stringify({ e: isEncrypted, d: data }); const hash = uint8ToBase64(new TextEncoder().encode(envelope)); const url = `${location.origin}${location.pathname}#${hash}`; els.linkPreview.textContent = url; els.linkPreview.classList.add('visible'); els.linkActions.style.display = 'flex'; els.linkPreview.dataset.url = url; showToast(isEncrypted ? 'Encrypted link generated!' : 'Link generated!', 'ðŸ”—'); } catch (e) { console.error(e); showToast('Failed to generate link', 'âš ï¸'); } }
const clearShareLink = () => { els.linkPreview.textContent = ''; els.linkPreview.classList.remove('visible'); els.linkActions.style.display = 'none'; els.passwordProtect.checked = false; els.sharePassword.value = ''; els.passwordGroup.classList.remove('visible'); };
async function parseShareLink() { const hash = location.hash.slice(1); if (!hash) return; try { const envelopeJson = new TextDecoder().decode(base64ToUint8(hash)); const envelope = JSON.parse(envelopeJson); if (envelope.e) { state.pendingShare = envelope; showPasswordModal(); } else { const compressed = base64ToUint8(envelope.d); const json = await decompress(compressed); importDocument(JSON.parse(json), false); } } catch (e) { console.error(e); showToast('Invalid share link', 'âš ï¸'); } history.replaceState(null, '', location.pathname); }
async function decryptAndImport(password) { if (!state.pendingShare) return; try { const encrypted = base64ToUint8(state.pendingShare.d); const compressedBase64 = await decrypt(encrypted, password); const compressed = base64ToUint8(compressedBase64); const json = await decompress(compressed); importDocument(JSON.parse(json), true); hidePasswordModal(); state.pendingShare = null; } catch (e) { console.error(e); els.modalError.classList.add('visible'); els.modalPassword.select(); } }
const importDocument = (payload, isEncrypted) => { createDocument(payload.title || 'Shared Document', payload.content || '', true, isEncrypted); showToast('Document imported!', 'ðŸ“¥'); };
const showPasswordModal = () => { els.passwordModal.classList.add('visible'); els.modalPassword.value = ''; els.modalError.classList.remove('visible'); setTimeout(() => els.modalPassword.focus(), 100); };
const hidePasswordModal = () => { els.passwordModal.classList.remove('visible'); state.pendingShare = null; };
const closeSidebar = () => { els.sidebar.classList.remove('open'); els.sidebarOverlay.classList.remove('visible'); };
const openSidebar = () => { els.sidebar.classList.add('open'); els.sidebarOverlay.classList.add('visible'); };
const closeSharePanel = () => { els.sharePanel.classList.remove('open'); els.shareOverlay.classList.remove('visible'); };
const openSharePanel = () => { els.sharePanel.classList.add('open'); els.shareOverlay.classList.add('visible'); };
const createWelcomeDocument = () => { createDocument('Welcome to DocEdit', `Welcome to DocEdit!\n\nA simple, private document editor that runs entirely in your browser.\n\nâœ¨ Features:\nâ€¢ All documents saved locally in your browser\nâ€¢ Share documents via encrypted links\nâ€¢ Password protection for sensitive content\nâ€¢ Dark & light themes\n\nðŸš€ Get started:\n1. Edit this document or create a new one\n2. Use the share panel to generate a shareable link\n3. Enable password protection for sensitive docs\n\nYour documents never leave your device unless you share them.\n\nHappy writing!`); };
function setupEventListeners() { els.newDocBtn.addEventListener('click', () => { createDocument(); closeSidebar(); }); els.deleteBtn.addEventListener('click', deleteCurrentDocument); els.docList.addEventListener('click', e => { const item = e.target.closest('.doc-item'); if (item) selectDocument(item.dataset.id); }); els.titleInput.addEventListener('input', debouncedSave); els.contentTextarea.addEventListener('input', debouncedSave); els.sortDate.addEventListener('click', () => { state.sortBy = 'date'; savePreferences(); renderDocList(); }); els.sortTitle.addEventListener('click', () => { state.sortBy = 'title'; savePreferences(); renderDocList(); }); els.themeToggle.addEventListener('click', cycleTheme); els.passwordProtect.addEventListener('change', () => { const c = els.passwordProtect.checked; els.passwordGroup.classList.toggle('visible', c); els.linkPreview.classList.remove('visible'); els.linkActions.style.display = 'none'; if (c) setTimeout(() => els.sharePassword.focus(), 200); }); els.sharePassword.addEventListener('input', () => { if (els.linkPreview.classList.contains('visible')) { els.linkPreview.classList.remove('visible'); els.linkActions.style.display = 'none'; } }); els.generateLink.addEventListener('click', generateShareLink); els.copyLink.addEventListener('click', async () => { const url = els.linkPreview.dataset.url; if (url) { await navigator.clipboard.writeText(url); showToast('Link copied!', 'ðŸ“‹'); } }); els.openLink.addEventListener('click', () => { const url = els.linkPreview.dataset.url; if (url) window.open(url, '_blank'); }); els.menuToggle.addEventListener('click', openSidebar); els.sidebarOverlay.addEventListener('click', closeSidebar); els.shareToggleMobile.addEventListener('click', openSharePanel); els.shareOverlay.addEventListener('click', closeSharePanel); els.modalCancel.addEventListener('click', hidePasswordModal); els.modalDecrypt.addEventListener('click', () => decryptAndImport(els.modalPassword.value)); els.modalPassword.addEventListener('keydown', e => { if (e.key === 'Enter') decryptAndImport(els.modalPassword.value); }); els.passwordModal.addEventListener('click', e => { if (e.target === els.passwordModal) hidePasswordModal(); }); window.matchMedia('(prefers-color-scheme:dark)').addEventListener('change', () => { if (state.theme === 'auto') applyTheme(); }); document.addEventListener('keydown', e => { if ((e.ctrlKey || e.metaKey) && e.key === 'n') { e.preventDefault(); createDocument(); } if (e.key === 'Escape') { hidePasswordModal(); closeSidebar(); closeSharePanel(); } }); }
function init() { loadPreferences(); loadDocuments(); applyTheme(); setupEventListeners(); if (location.hash) parseShareLink(); if (state.documents.length === 0) createWelcomeDocument(); else { renderDocList(); selectDocument(getSortedDocuments()[0].id); } }
init();
